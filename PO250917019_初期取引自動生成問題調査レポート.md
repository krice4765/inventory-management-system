# PO250917019 初期取引自動生成問題調査レポート

## 📋 調査概要

**調査対象**: 発注書PO250917019の初期取引（¥16,500等）が自動生成される問題
**調査日時**: 2025-09-17
**調査目的**: 初期取引自動生成の原因特定と根本的解決策の提案

## 🔍 問題の詳細

### 現象
- 新規発注書作成時に、ユーザーの意図しない初期取引が自動的に生成される
- 取引金額が¥16,500などの具体的な金額で自動作成される
- この初期取引により、分納システムとの整合性に問題が発生

### 影響範囲
- 全ての新規発注書作成
- 分納システムの運用
- ユーザビリティの低下

## 🎯 根本原因の特定

### 原因1: データベーストリガー
**ファイル**: `scripts/database_maintenance.sql`
**関数**: `fn_sync_transaction_from_po()`
**トリガー**: `trigger_sync_transaction_from_po` または `sync_transaction_from_po_trigger`

```sql
CREATE OR REPLACE FUNCTION public.fn_sync_transaction_from_po()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO public.transactions (
    id, transaction_no, transaction_type, partner_id,
    transaction_date, due_date, status, total_amount,
    memo, parent_order_id, installment_no, created_at
  )
  VALUES (
    gen_random_uuid(),
    'TX-' || to_char(clock_timestamp(),'YYYYMMDD-HH24MISSMS') || '-' || substr(md5(random()::text),1,6),
    'purchase',
    NEW.partner_id,
    NEW.order_date,
    NEW.delivery_deadline,
    'draft',
    NEW.total_amount,  -- ←ここで発注書の金額がそのまま取引に設定される
    NEW.memo,
    NEW.id,
    1,  -- installment_no = 1で初期取引として作成
    now()
  )
  ON CONFLICT (parent_order_id, transaction_type, installment_no) DO NOTHING;
  RETURN NEW;
END;
$function$;
```

### 原因2: トリガーの自動実行
発注書が`purchase_orders`テーブルにINSERTされると、このトリガーが自動的に実行され、`transactions`テーブルに初期取引レコードが作成される。

### OrderNew.tsxでの実行フロー
1. ユーザーがOrderNew.tsxで発注書を作成
2. `create_purchase_order()` RPC関数が実行される
3. `purchase_orders`テーブルにレコードがINSERT
4. **🚨 トリガー `fn_sync_transaction_from_po()` が自動実行**
5. `transactions`テーブルに初期取引が自動生成される

## 💡 修正提案

### 🎯 推奨解決策: トリガーの完全削除

**理由**:
- 発注書作成時の自動取引生成は業務フローに合わない
- 分納は必要に応じてユーザーが明示的に作成すべき
- システムの予測可能性と制御性の向上

**実装方法**:
```sql
-- トリガーの削除
DROP TRIGGER IF EXISTS trigger_sync_transaction_from_po ON purchase_orders;
DROP TRIGGER IF EXISTS sync_transaction_from_po_trigger ON purchase_orders;
```

### 🔧 代替解決策

#### 選択肢2: 条件付きトリガー
```sql
-- 特定の条件でのみ実行
IF NEW.status = 'confirmed' THEN
  -- 取引生成処理
END IF;
```

#### 選択肢3: トリガーの無効化
```sql
ALTER TABLE purchase_orders DISABLE TRIGGER trigger_sync_transaction_from_po;
```

## 📝 実装手順

### ステップ1: 現状確認
1. `fix_po250917019_auto_transaction_issue.sql` を実行
2. 現在のトリガー状況を確認

### ステップ2: トリガー削除
1. 問題のトリガーを削除
2. 関数の削除も検討

### ステップ3: クリーンアップ
1. 既存の不要な初期取引を特定
2. 必要に応じて削除（慎重に実行）

### ステップ4: 動作確認
1. OrderNew.tsxから新規発注書を作成
2. 自動取引が生成されないことを確認

## 🔄 今後の運用フロー

### 新しい発注書作成フロー
1. **発注書作成**: OrderNew.tsxで発注書のみ作成
2. **分納追加**: 必要に応じてユーザーが手動で分納を追加
3. **自動生成なし**: システムが勝手に取引を作成しない

### 分納システムの適切な利用
- `create_installment_v2()` 関数を使用
- ユーザーの明示的な操作でのみ分納を作成
- 分納回次の適切な管理

## ✅ 期待される効果

### immediate Benefits
1. **不要な初期取引の排除**: PO250917019のような問題の根本解決
2. **ユーザビリティ向上**: ユーザーが意図しない取引が作成されない
3. **システムの予測可能性**: 明確な処理フローの実現

### Long-term Benefits
1. **保守性向上**: トリガーによる複雑な副作用の削除
2. **データ整合性**: 分納システムとの整合性確保
3. **運用効率化**: 事後修正作業の削減

## 🚨 注意事項

### 実行前の確認事項
1. **バックアップ必須**: データベースの完全バックアップを取得
2. **影響範囲の確認**: 他のシステムでこのトリガーに依存していないか確認
3. **段階的実行**: テスト環境での動作確認を推奨

### 実行後の監視事項
1. **新規発注書の動作確認**: 初期取引が生成されないことを確認
2. **分納機能の動作確認**: 手動分納が正常に動作することを確認
3. **既存データの整合性**: 過去のデータに影響がないことを確認

## 📁 関連ファイル

### 修正対象ファイル
- `scripts/database_maintenance.sql` - 問題のトリガー関数
- `fix_po250917019_auto_transaction_issue.sql` - 修正スクリプト

### 確認対象ファイル
- `src/pages/OrderNew.tsx` - 発注書作成UI
- `scripts/fix_installment_constraints.sql` - 分納システム
- `complete_rpc_fix.sql` - 分納RPC関数

### 調査用ファイル
- `investigate_po250917019.sql` - データ調査用クエリ

## 🎯 結論

PO250917019の初期取引自動生成問題は、データベーストリガー `fn_sync_transaction_from_po()` が原因です。このトリガーを削除することで、発注書作成時の不要な初期取引生成を完全に防ぐことができます。

この修正により、ユーザーフレンドリーで予測可能なシステムを実現し、事後修正が不要なクリーンな運用が可能になります。

---

**調査実施者**: Claude Code
**レポート作成日**: 2025-09-17
**推奨実行優先度**: 🔴 高（即座の対応推奨）